diff --git a/drivers/usb/musb/Kconfig b/drivers/usb/musb/Kconfig
index 58b2b8f..4b9542b 100644
--- a/drivers/usb/musb/Kconfig
+++ b/drivers/usb/musb/Kconfig
@@ -33,10 +33,6 @@ config USB_MUSB_SOC
 	default y if ARCH_DAVINCI
 	default y if ARCH_OMAP2430
 	default y if ARCH_OMAP34XX
-	help
-	  Use a static <asm/arch/hdrc_cnf.h> file to describe how the
-	  controller is configured (endpoints, mechanisms, etc) on the
-	  current iteration of a given system-on-chip.
 
 comment "DaVinci 644x USB support"
 	depends on USB_MUSB_HDRC && ARCH_DAVINCI
diff --git a/drivers/usb/musb/cppi_dma.h b/drivers/usb/musb/cppi_dma.h
index fc5216b..729b407 100644
--- a/drivers/usb/musb/cppi_dma.h
+++ b/drivers/usb/musb/cppi_dma.h
@@ -119,8 +119,8 @@ struct cppi {
 	void __iomem			*mregs;		/* Mentor regs */
 	void __iomem			*tibase;	/* TI/CPPI regs */
 
-	struct cppi_channel		tx[MUSB_C_NUM_EPT - 1];
-	struct cppi_channel		rx[MUSB_C_NUM_EPR - 1];
+	struct cppi_channel		tx[4];
+	struct cppi_channel		rx[4];
 
 	struct dma_pool			*pool;
 
diff --git a/drivers/usb/musb/davinci.c b/drivers/usb/musb/davinci.c
index 217f497..4e97d53 100644
--- a/drivers/usb/musb/davinci.c
+++ b/drivers/usb/musb/davinci.c
@@ -30,6 +30,7 @@
 #include <linux/delay.h>
 #include <linux/clk.h>
 #include <linux/io.h>
+#include <linux/gpio.h>
 
 #include <mach/hardware.h>
 #include <mach/gpio.h>
@@ -39,7 +40,7 @@
 #include "musb_core.h"
 
 #ifdef CONFIG_MACH_DAVINCI_EVM
-#include <mach/i2c-client.h>
+#define GPIO_nVBUS_DRV		87
 #endif
 
 #include "davinci.h"
@@ -138,7 +139,6 @@ static int vbus_state = -1;
 /* VBUS SWITCHING IS BOARD-SPECIFIC */
 
 #ifdef CONFIG_MACH_DAVINCI_EVM
-#ifndef CONFIG_MACH_DAVINCI_EVM_OTG
 
 /* I2C operations are always synchronous, and require a task context.
  * With unloaded systems, using the shared workqueue seems to suffice
@@ -146,12 +146,11 @@ static int vbus_state = -1;
  */
 static void evm_deferred_drvvbus(struct work_struct *ignored)
 {
-	davinci_i2c_expander_op(0x3a, USB_DRVVBUS, vbus_state);
+	gpio_set_value_cansleep(GPIO_nVBUS_DRV, vbus_state);
 	vbus_state = !vbus_state;
 }
 static DECLARE_WORK(evm_vbus_work, evm_deferred_drvvbus);
 
-#endif	/* modified board */
 #endif	/* EVM */
 
 static void davinci_source_power(struct musb *musb, int is_on, int immediate)
@@ -165,21 +164,10 @@ static void davinci_source_power(struct musb *musb, int is_on, int immediate)
 
 #ifdef CONFIG_MACH_DAVINCI_EVM
 	if (machine_is_davinci_evm()) {
-#ifdef CONFIG_MACH_DAVINCI_EVM_OTG
-		/* modified EVM board switching VBUS with GPIO(6) not I2C
-		 * NOTE:  PINMUX0.RGB888 (bit23) must be clear
-		 */
-		if (is_on)
-			gpio_set(GPIO(6));
-		else
-			gpio_clear(GPIO(6));
-		immediate = 1;
-#else
 		if (immediate)
-			davinci_i2c_expander_op(0x3a, USB_DRVVBUS, !is_on);
+			gpio_set_value_cansleep(GPIO_nVBUS_DRV, vbus_state);
 		else
 			schedule_work(&evm_vbus_work);
-#endif
 	}
 #endif
 	if (immediate)
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 128e949..64d2af1 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -82,9 +82,9 @@
 /*
  * This gets many kinds of configuration information:
  *	- Kconfig for everything user-configurable
- *	- <asm/arch/hdrc_cnf.h> for SOC or family details
  *	- platform_device for addressing, irq, and platform_data
  *	- platform_data is mostly for board-specific informarion
+ *	  (plus recentrly, SOC or family details)
  *
  * Most of the conditional compilation will (someday) vanish.
  */
@@ -974,9 +974,9 @@ static void musb_shutdown(struct platform_device *pdev)
 /*
  * The silicon either has hard-wired endpoint configurations, or else
  * "dynamic fifo" sizing.  The driver has support for both, though at this
- * writing only the dynamic sizing is very well tested.   We use normal
- * idioms to so both modes are compile-tested, but dead code elimination
- * leaves only the relevant one in the object file.
+ * writing only the dynamic sizing is very well tested.   Since we switched
+ * away from compile-time hardware parameters, we can no longer rely on
+ * dead code elimination to leave only the relevant one in the object file.
  *
  * We don't currently use dynamic fifo setup capability to do anything
  * more than selecting one of a bunch of predefined configurations.
@@ -2054,15 +2054,6 @@ bad_config:
 
 	}
 
-	return 0;
-
-fail:
-	if (musb->clock)
-		clk_put(musb->clock);
-	device_init_wakeup(dev, 0);
-	musb_free(musb);
-	return status;
-
 #ifdef CONFIG_SYSFS
 	status = device_create_file(dev, &dev_attr_mode);
 	status = device_create_file(dev, &dev_attr_vbus);
@@ -2071,12 +2062,31 @@ fail:
 #endif /* CONFIG_USB_GADGET_MUSB_HDRC */
 	status = 0;
 #endif
+	if (status)
+		goto fail2;
 
-	return status;
+	return 0;
 
 fail2:
+#ifdef CONFIG_SYSFS
+	device_remove_file(musb->controller, &dev_attr_mode);
+	device_remove_file(musb->controller, &dev_attr_vbus);
+#ifdef CONFIG_USB_MUSB_OTG
+	device_remove_file(musb->controller, &dev_attr_srp);
+#endif
+#endif
 	musb_platform_exit(musb);
-	goto fail;
+fail:
+	dev_err(musb->controller,
+		"musb_init_controller failed with status %d\n", status);
+
+	if (musb->clock)
+		clk_put(musb->clock);
+	device_init_wakeup(dev, 0);
+	musb_free(musb);
+
+	return status;
+
 }
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/musb/musb_gadget_ep0.c b/drivers/usb/musb/musb_gadget_ep0.c
index a57652f..3f5e30d 100644
--- a/drivers/usb/musb/musb_gadget_ep0.c
+++ b/drivers/usb/musb/musb_gadget_ep0.c
@@ -437,7 +437,7 @@ static void ep0_rxstate(struct musb *musb)
 {
 	void __iomem		*regs = musb->control_ep->regs;
 	struct usb_request	*req;
-	u16			tmp;
+	u16			count, csr;
 
 	req = next_ep0_request(musb);
 
@@ -449,35 +449,35 @@ static void ep0_rxstate(struct musb *musb)
 		unsigned	len = req->length - req->actual;
 
 		/* read the buffer */
-		tmp = musb_readb(regs, MUSB_COUNT0);
-		if (tmp > len) {
+		count = musb_readb(regs, MUSB_COUNT0);
+		if (count > len) {
 			req->status = -EOVERFLOW;
-			tmp = len;
+			count = len;
 		}
-		musb_read_fifo(&musb->endpoints[0], tmp, buf);
-		req->actual += tmp;
-		tmp = MUSB_CSR0_P_SVDRXPKTRDY;
-		if (tmp < 64 || req->actual == req->length) {
+		musb_read_fifo(&musb->endpoints[0], count, buf);
+		req->actual += count;
+		csr = MUSB_CSR0_P_SVDRXPKTRDY;
+		if (count < 64 || req->actual == req->length) {
 			musb->ep0_state = MUSB_EP0_STAGE_STATUSIN;
-			tmp |= MUSB_CSR0_P_DATAEND;
+			csr |= MUSB_CSR0_P_DATAEND;
 		} else
 			req = NULL;
 	} else
-		tmp = MUSB_CSR0_P_SVDRXPKTRDY | MUSB_CSR0_P_SENDSTALL;
+		csr = MUSB_CSR0_P_SVDRXPKTRDY | MUSB_CSR0_P_SENDSTALL;
 
 
 	/* Completion handler may choose to stall, e.g. because the
 	 * message just received holds invalid data.
 	 */
 	if (req) {
-		musb->ackpend = tmp;
+		musb->ackpend = csr;
 		musb_g_ep0_giveback(musb, req);
 		if (!musb->ackpend)
 			return;
 		musb->ackpend = 0;
 	}
 	musb_ep_select(musb->mregs, 0);
-	musb_writew(regs, MUSB_CSR0, tmp);
+	musb_writew(regs, MUSB_CSR0, csr);
 }
 
 /*
diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index 8b4be01..3133990 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -108,7 +108,7 @@ static void musb_ep_program(struct musb *musb, u8 epnum,
 /*
  * Clear TX fifo. Needed to avoid BABBLE errors.
  */
-static inline void musb_h_tx_flush_fifo(struct musb_hw_ep *ep)
+static void musb_h_tx_flush_fifo(struct musb_hw_ep *ep)
 {
 	void __iomem	*epio = ep->regs;
 	u16		csr;
@@ -291,6 +291,7 @@ __acquires(musb->lock)
 			urb->actual_length, urb->transfer_buffer_length
 			);
 
+	usb_hcd_unlink_urb_from_ep(musb_to_hcd(musb), urb);
 	spin_unlock(&musb->lock);
 	usb_hcd_giveback_urb(musb_to_hcd(musb), urb, status);
 	spin_lock(&musb->lock);
@@ -353,8 +354,6 @@ musb_giveback(struct musb_qh *qh, struct urb *urb, int status)
 		break;
 	}
 
-	usb_hcd_unlink_urb_from_ep(musb_to_hcd(musb), urb);
-
 	qh->is_ready = 0;
 	__musb_giveback(musb, urb, status);
 	qh->is_ready = ready;
@@ -436,7 +435,7 @@ musb_advance_schedule(struct musb *musb, struct urb *urb,
 	}
 }
 
-static inline u16 musb_h_flush_rxfifo(struct musb_hw_ep *hw_ep, u16 csr)
+static u16 musb_h_flush_rxfifo(struct musb_hw_ep *hw_ep, u16 csr)
 {
 	/* we don't want fifo to fill itself again;
 	 * ignore dma (various models),
@@ -1005,7 +1004,7 @@ static bool musb_h_ep0_continue(struct musb *musb, u16 len, struct urb *urb)
 
 /*
  * Handle default endpoint interrupt as host. Only called in IRQ time
- * from the LinuxIsr() interrupt service routine.
+ * from musb_interrupt().
  *
  * called with controller irqlocked
  */
@@ -1791,7 +1790,9 @@ static int musb_urb_enqueue(
 	 */
 	qh = kzalloc(sizeof *qh, mem_flags);
 	if (!qh) {
+		spin_lock_irqsave(&musb->lock, flags);
 		usb_hcd_unlink_urb_from_ep(hcd, urb);
+		spin_unlock_irqrestore(&musb->lock, flags);
 		return -ENOMEM;
 	}
 
@@ -1873,7 +1874,11 @@ static int musb_urb_enqueue(
 			/* set up tt info if needed */
 			if (urb->dev->tt) {
 				qh->h_port_reg = (u8) urb->dev->ttport;
-				qh->h_addr_reg |= 0x80;
+				if (urb->dev->tt->hub)
+					qh->h_addr_reg =
+						(u8) urb->dev->tt->hub->devnum;
+				if (urb->dev->tt->multi)
+					qh->h_addr_reg |= 0x80;
 			}
 		}
 	}
@@ -1903,7 +1908,9 @@ static int musb_urb_enqueue(
 
 done:
 	if (ret != 0) {
+		spin_lock_irqsave(&musb->lock, flags);
 		usb_hcd_unlink_urb_from_ep(hcd, urb);
+		spin_unlock_irqrestore(&musb->lock, flags);
 		kfree(qh);
 	}
 	return ret;
diff --git a/drivers/usb/musb/musb_io.h b/drivers/usb/musb/musb_io.h
index 6bbedae..223f0a5 100644
--- a/drivers/usb/musb/musb_io.h
+++ b/drivers/usb/musb/musb_io.h
@@ -37,7 +37,9 @@
 
 #include <linux/io.h>
 
-#ifndef	CONFIG_ARM
+#if !defined(CONFIG_ARM) && !defined(CONFIG_SUPERH) \
+	&& !defined(CONFIG_AVR32) && !defined(CONFIG_PPC32) \
+	&& !defined(CONFIG_PPC64)
 static inline void readsl(const void __iomem *addr, void *buf, int len)
 	{ insl((unsigned long)addr, buf, len); }
 static inline void readsw(const void __iomem *addr, void *buf, int len)
diff --git a/drivers/usb/musb/musbhsdma.c b/drivers/usb/musb/musbhsdma.c
index 9ba8fb7..8c734ef 100644
--- a/drivers/usb/musb/musbhsdma.c
+++ b/drivers/usb/musb/musbhsdma.c
@@ -45,8 +45,8 @@
 #define MUSB_HSDMA_ADDRESS		0x8
 #define MUSB_HSDMA_COUNT		0xc
 
-#define MUSB_HSDMA_CHANNEL_OFFSET(_bChannel, _offset)		\
-		(MUSB_HSDMA_BASE + (_bChannel << 4) + _offset)
+#define MUSB_HSDMA_CHANNEL_OFFSET(_bchannel, _offset)		\
+		(MUSB_HSDMA_BASE + (_bchannel << 4) + _offset)
 
 /* control register (16-bit): */
 #define MUSB_HSDMA_ENABLE_SHIFT		0
@@ -67,23 +67,23 @@
 struct musb_dma_controller;
 
 struct musb_dma_channel {
-	struct dma_channel		Channel;
+	struct dma_channel		channel;
 	struct musb_dma_controller	*controller;
-	u32				dwStartAddress;
+	u32				start_addr;
 	u32				len;
-	u16				wMaxPacketSize;
-	u8				bIndex;
+	u16				max_packet_sz;
+	u8				idx;
 	u8				epnum;
 	u8				transmit;
 };
 
 struct musb_dma_controller {
-	struct dma_controller		Controller;
-	struct musb_dma_channel		aChannel[MUSB_HSDMA_CHANNELS];
-	void				*pDmaPrivate;
-	void __iomem			*pCoreBase;
-	u8				bChannelCount;
-	u8				bmUsedChannels;
+	struct dma_controller		controller;
+	struct musb_dma_channel		channel[MUSB_HSDMA_CHANNELS];
+	void				*private_data;
+	void __iomem			*base;
+	u8				channel_count;
+	u8				used_channels;
 	u8				irq;
 };
 
@@ -93,91 +93,91 @@ static int dma_controller_start(struct dma_controller *c)
 	return 0;
 }
 
-static void dma_channel_release(struct dma_channel *pChannel);
+static void dma_channel_release(struct dma_channel *channel);
 
 static int dma_controller_stop(struct dma_controller *c)
 {
-	struct musb_dma_controller *controller =
-		container_of(c, struct musb_dma_controller, Controller);
-	struct musb *musb = (struct musb *) controller->pDmaPrivate;
-	struct dma_channel *pChannel;
-	u8 bBit;
+	struct musb_dma_controller *controller = container_of(c,
+			struct musb_dma_controller, controller);
+	struct musb *musb = controller->private_data;
+	struct dma_channel *channel;
+	u8 bit;
 
-	if (controller->bmUsedChannels != 0) {
+	if (controller->used_channels != 0) {
 		dev_err(musb->controller,
 			"Stopping DMA controller while channel active\n");
 
-		for (bBit = 0; bBit < MUSB_HSDMA_CHANNELS; bBit++) {
-			if (controller->bmUsedChannels & (1 << bBit)) {
-				pChannel = &controller->aChannel[bBit].Channel;
-				dma_channel_release(pChannel);
+		for (bit = 0; bit < MUSB_HSDMA_CHANNELS; bit++) {
+			if (controller->used_channels & (1 << bit)) {
+				channel = &controller->channel[bit].channel;
+				dma_channel_release(channel);
 
-				if (!controller->bmUsedChannels)
+				if (!controller->used_channels)
 					break;
 			}
 		}
 	}
+
 	return 0;
 }
 
 static struct dma_channel *dma_channel_allocate(struct dma_controller *c,
 				struct musb_hw_ep *hw_ep, u8 transmit)
 {
-	u8 bBit;
-	struct dma_channel *pChannel = NULL;
-	struct musb_dma_channel *pImplChannel = NULL;
-	struct musb_dma_controller *controller =
-			container_of(c, struct musb_dma_controller, Controller);
-
-	for (bBit = 0; bBit < MUSB_HSDMA_CHANNELS; bBit++) {
-		if (!(controller->bmUsedChannels & (1 << bBit))) {
-			controller->bmUsedChannels |= (1 << bBit);
-			pImplChannel = &(controller->aChannel[bBit]);
-			pImplChannel->controller = controller;
-			pImplChannel->bIndex = bBit;
-			pImplChannel->epnum = hw_ep->epnum;
-			pImplChannel->transmit = transmit;
-			pChannel = &(pImplChannel->Channel);
-			pChannel->private_data = pImplChannel;
-			pChannel->status = MUSB_DMA_STATUS_FREE;
-			pChannel->max_len = 0x10000;
+	struct musb_dma_controller *controller = container_of(c,
+			struct musb_dma_controller, controller);
+	struct musb_dma_channel *musb_channel = NULL;
+	struct dma_channel *channel = NULL;
+	u8 bit;
+
+	for (bit = 0; bit < MUSB_HSDMA_CHANNELS; bit++) {
+		if (!(controller->used_channels & (1 << bit))) {
+			controller->used_channels |= (1 << bit);
+			musb_channel = &(controller->channel[bit]);
+			musb_channel->controller = controller;
+			musb_channel->idx = bit;
+			musb_channel->epnum = hw_ep->epnum;
+			musb_channel->transmit = transmit;
+			channel = &(musb_channel->channel);
+			channel->private_data = musb_channel;
+			channel->status = MUSB_DMA_STATUS_FREE;
+			channel->max_len = 0x10000;
 			/* Tx => mode 1; Rx => mode 0 */
-			pChannel->desired_mode = transmit;
-			pChannel->actual_len = 0;
+			channel->desired_mode = transmit;
+			channel->actual_len = 0;
 			break;
 		}
 	}
-	return pChannel;
+
+	return channel;
 }
 
-static void dma_channel_release(struct dma_channel *pChannel)
+static void dma_channel_release(struct dma_channel *channel)
 {
-	struct musb_dma_channel *pImplChannel =
-		(struct musb_dma_channel *) pChannel->private_data;
+	struct musb_dma_channel *musb_channel = channel->private_data;
 
-	pChannel->actual_len = 0;
-	pImplChannel->dwStartAddress = 0;
-	pImplChannel->len = 0;
+	channel->actual_len = 0;
+	musb_channel->start_addr = 0;
+	musb_channel->len = 0;
 
-	pImplChannel->controller->bmUsedChannels &=
-		~(1 << pImplChannel->bIndex);
+	musb_channel->controller->used_channels &=
+		~(1 << musb_channel->idx);
 
-	pChannel->status = MUSB_DMA_STATUS_UNKNOWN;
+	channel->status = MUSB_DMA_STATUS_UNKNOWN;
 }
 
-static void configure_channel(struct dma_channel *pChannel,
+static void configure_channel(struct dma_channel *channel,
 				u16 packet_sz, u8 mode,
 				dma_addr_t dma_addr, u32 len)
 {
-	struct musb_dma_channel *pImplChannel =
-		(struct musb_dma_channel *) pChannel->private_data;
-	struct musb_dma_controller *controller = pImplChannel->controller;
-	void __iomem *mbase = controller->pCoreBase;
-	u8 bChannel = pImplChannel->bIndex;
+	struct musb_dma_channel *musb_channel = channel->private_data;
+	struct musb_dma_controller *controller = musb_channel->controller;
+	void __iomem *mbase = controller->base;
+	u8 bchannel = musb_channel->idx;
 	u16 csr = 0;
 
 	DBG(4, "%p, pkt_sz %d, addr 0x%x, len %d, mode %d\n",
-			pChannel, packet_sz, dma_addr, len, mode);
+			channel, packet_sz, dma_addr, len, mode);
 
 	if (mode) {
 		csr |= 1 << MUSB_HSDMA_MODE1_SHIFT;
@@ -195,180 +195,183 @@ static void configure_channel(struct dma_channel *pChannel,
 		}
 	}
 
-	csr |= (pImplChannel->epnum << MUSB_HSDMA_ENDPOINT_SHIFT)
+	csr |= (musb_channel->epnum << MUSB_HSDMA_ENDPOINT_SHIFT)
 		| (1 << MUSB_HSDMA_ENABLE_SHIFT)
 		| (1 << MUSB_HSDMA_IRQENABLE_SHIFT)
-		| (pImplChannel->transmit
+		| (musb_channel->transmit
 				? (1 << MUSB_HSDMA_TRANSMIT_SHIFT)
 				: 0);
 
 	/* address/count */
 	musb_writel(mbase,
-		MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_ADDRESS),
+		MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_ADDRESS),
 		dma_addr);
 	musb_writel(mbase,
-		MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_COUNT),
+		MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_COUNT),
 		len);
 
 	/* control (this should start things) */
 	musb_writew(mbase,
-		MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_CONTROL),
+		MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_CONTROL),
 		csr);
 }
 
-static int dma_channel_program(struct dma_channel *pChannel,
+static int dma_channel_program(struct dma_channel *channel,
 				u16 packet_sz, u8 mode,
 				dma_addr_t dma_addr, u32 len)
 {
-	struct musb_dma_channel *pImplChannel =
-			(struct musb_dma_channel *) pChannel->private_data;
+	struct musb_dma_channel *musb_channel = channel->private_data;
 
 	DBG(2, "ep%d-%s pkt_sz %d, dma_addr 0x%x length %d, mode %d\n",
-		pImplChannel->epnum,
-		pImplChannel->transmit ? "Tx" : "Rx",
+		musb_channel->epnum,
+		musb_channel->transmit ? "Tx" : "Rx",
 		packet_sz, dma_addr, len, mode);
 
-	BUG_ON(pChannel->status == MUSB_DMA_STATUS_UNKNOWN ||
-		pChannel->status == MUSB_DMA_STATUS_BUSY);
+	BUG_ON(channel->status == MUSB_DMA_STATUS_UNKNOWN ||
+		channel->status == MUSB_DMA_STATUS_BUSY);
 
-	pChannel->actual_len = 0;
-	pImplChannel->dwStartAddress = dma_addr;
-	pImplChannel->len = len;
-	pImplChannel->wMaxPacketSize = packet_sz;
-	pChannel->status = MUSB_DMA_STATUS_BUSY;
+	channel->actual_len = 0;
+	musb_channel->start_addr = dma_addr;
+	musb_channel->len = len;
+	musb_channel->max_packet_sz = packet_sz;
+	channel->status = MUSB_DMA_STATUS_BUSY;
 
 	if ((mode == 1) && (len >= packet_sz))
-		configure_channel(pChannel, packet_sz, 1, dma_addr, len);
+		configure_channel(channel, packet_sz, 1, dma_addr, len);
 	else
-		configure_channel(pChannel, packet_sz, 0, dma_addr, len);
+		configure_channel(channel, packet_sz, 0, dma_addr, len);
 
 	return true;
 }
 
-static int dma_channel_abort(struct dma_channel *pChannel)
+static int dma_channel_abort(struct dma_channel *channel)
 {
-	struct musb_dma_channel *pImplChannel =
-		(struct musb_dma_channel *) pChannel->private_data;
-	u8 bChannel = pImplChannel->bIndex;
-	void __iomem *mbase = pImplChannel->controller->pCoreBase;
+	struct musb_dma_channel *musb_channel = channel->private_data;
+	void __iomem *mbase = musb_channel->controller->base;
+
+	u8 bchannel = musb_channel->idx;
 	u16 csr;
 
-	if (pChannel->status == MUSB_DMA_STATUS_BUSY) {
-		if (pImplChannel->transmit) {
+	if (channel->status == MUSB_DMA_STATUS_BUSY) {
+		if (musb_channel->transmit) {
 
 			csr = musb_readw(mbase,
-				MUSB_EP_OFFSET(pImplChannel->epnum,
+				MUSB_EP_OFFSET(musb_channel->epnum,
 						MUSB_TXCSR));
 			csr &= ~(MUSB_TXCSR_AUTOSET |
 				 MUSB_TXCSR_DMAENAB |
 				 MUSB_TXCSR_DMAMODE);
 			musb_writew(mbase,
-				MUSB_EP_OFFSET(pImplChannel->epnum,
-						MUSB_TXCSR),
+				MUSB_EP_OFFSET(musb_channel->epnum, MUSB_TXCSR),
 				csr);
 		} else {
 			csr = musb_readw(mbase,
-				MUSB_EP_OFFSET(pImplChannel->epnum,
+				MUSB_EP_OFFSET(musb_channel->epnum,
 						MUSB_RXCSR));
 			csr &= ~(MUSB_RXCSR_AUTOCLEAR |
 				 MUSB_RXCSR_DMAENAB |
 				 MUSB_RXCSR_DMAMODE);
 			musb_writew(mbase,
-				MUSB_EP_OFFSET(pImplChannel->epnum,
-						MUSB_RXCSR),
+				MUSB_EP_OFFSET(musb_channel->epnum, MUSB_RXCSR),
 				csr);
 		}
 
 		musb_writew(mbase,
-			MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_CONTROL),
+			MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_CONTROL),
 			0);
 		musb_writel(mbase,
-			MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_ADDRESS),
+			MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_ADDRESS),
 			0);
 		musb_writel(mbase,
-			MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_COUNT),
+			MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_COUNT),
 			0);
 
-		pChannel->status = MUSB_DMA_STATUS_FREE;
+		channel->status = MUSB_DMA_STATUS_FREE;
 	}
+
 	return 0;
 }
 
 static irqreturn_t dma_controller_irq(int irq, void *private_data)
 {
-	struct musb_dma_controller *controller =
-		(struct musb_dma_controller *)private_data;
-	struct musb_dma_channel *pImplChannel;
-	struct musb *musb = controller->pDmaPrivate;
-	void __iomem *mbase = controller->pCoreBase;
-	struct dma_channel *pChannel;
-	u8 bChannel;
-	u16 csr;
-	u32 dwAddress;
-	u8 int_hsdma;
+	struct musb_dma_controller *controller = private_data;
+	struct musb *musb = controller->private_data;
+	struct musb_dma_channel *musb_channel;
+	struct dma_channel *channel;
+
+	void __iomem *mbase = controller->base;
+
 	irqreturn_t retval = IRQ_NONE;
+
 	unsigned long flags;
 
+	u8 bchannel;
+	u8 int_hsdma;
+
+	u32 addr;
+	u16 csr;
+
 	spin_lock_irqsave(&musb->lock, flags);
 
 	int_hsdma = musb_readb(mbase, MUSB_HSDMA_INTR);
 	if (!int_hsdma)
 		goto done;
 
-	for (bChannel = 0; bChannel < MUSB_HSDMA_CHANNELS; bChannel++) {
-		if (int_hsdma & (1 << bChannel)) {
-			pImplChannel = (struct musb_dma_channel *)
-					&(controller->aChannel[bChannel]);
-			pChannel = &pImplChannel->Channel;
+	for (bchannel = 0; bchannel < MUSB_HSDMA_CHANNELS; bchannel++) {
+		if (int_hsdma & (1 << bchannel)) {
+			musb_channel = (struct musb_dma_channel *)
+					&(controller->channel[bchannel]);
+			channel = &musb_channel->channel;
 
 			csr = musb_readw(mbase,
-					MUSB_HSDMA_CHANNEL_OFFSET(bChannel,
+					MUSB_HSDMA_CHANNEL_OFFSET(bchannel,
 							MUSB_HSDMA_CONTROL));
 
-			if (csr & (1 << MUSB_HSDMA_BUSERROR_SHIFT))
-				pImplChannel->Channel.status =
+			if (csr & (1 << MUSB_HSDMA_BUSERROR_SHIFT)) {
+				musb_channel->channel.status =
 					MUSB_DMA_STATUS_BUS_ABORT;
-			else {
+			} else {
 				u8 devctl;
 
-				dwAddress = musb_readl(mbase,
+				addr = musb_readl(mbase,
 						MUSB_HSDMA_CHANNEL_OFFSET(
-							bChannel,
+							bchannel,
 							MUSB_HSDMA_ADDRESS));
-				pChannel->actual_len = dwAddress
-					- pImplChannel->dwStartAddress;
+				channel->actual_len = addr
+					- musb_channel->start_addr;
 
 				DBG(2, "ch %p, 0x%x -> 0x%x (%d / %d) %s\n",
-					pChannel, pImplChannel->dwStartAddress,
-					dwAddress, pChannel->actual_len,
-					pImplChannel->len,
-					(pChannel->actual_len
-						< pImplChannel->len) ?
+					channel, musb_channel->start_addr,
+					addr, channel->actual_len,
+					musb_channel->len,
+					(channel->actual_len
+						< musb_channel->len) ?
 					"=> reconfig 0" : "=> complete");
 
 				devctl = musb_readb(mbase, MUSB_DEVCTL);
 
-				pChannel->status = MUSB_DMA_STATUS_FREE;
+				channel->status = MUSB_DMA_STATUS_FREE;
 
 				/* completed */
 				if ((devctl & MUSB_DEVCTL_HM)
-					&& (pImplChannel->transmit)
-					&& ((pChannel->desired_mode == 0)
-					    || (pChannel->actual_len &
-					    (pImplChannel->wMaxPacketSize - 1)))
+					&& (musb_channel->transmit)
+					&& ((channel->desired_mode == 0)
+					    || (channel->actual_len &
+					    (musb_channel->max_packet_sz - 1)))
 					 ) {
 					/* Send out the packet */
 					musb_ep_select(mbase,
-						pImplChannel->epnum);
+						musb_channel->epnum);
 					musb_writew(mbase, MUSB_EP_OFFSET(
-							pImplChannel->epnum,
+							musb_channel->epnum,
 							MUSB_TXCSR),
 						MUSB_TXCSR_TXPKTRDY);
-				} else
+				} else {
 					musb_dma_completion(
 						musb,
-						pImplChannel->epnum,
-						pImplChannel->transmit);
+						musb_channel->epnum,
+						musb_channel->transmit);
+				}
 			}
 		}
 	}
@@ -380,9 +383,9 @@ done:
 
 void dma_controller_destroy(struct dma_controller *c)
 {
-	struct musb_dma_controller *controller;
+	struct musb_dma_controller *controller = container_of(c,
+			struct musb_dma_controller, controller);
 
-	controller = container_of(c, struct musb_dma_controller, Controller);
 	if (!controller)
 		return;
 
@@ -393,7 +396,7 @@ void dma_controller_destroy(struct dma_controller *c)
 }
 
 struct dma_controller *__init
-dma_controller_create(struct musb *musb, void __iomem *pCoreBase)
+dma_controller_create(struct musb *musb, void __iomem *base)
 {
 	struct musb_dma_controller *controller;
 	struct device *dev = musb->controller;
@@ -405,29 +408,30 @@ dma_controller_create(struct musb *musb, void __iomem *pCoreBase)
 		return NULL;
 	}
 
-	controller = kzalloc(sizeof(struct musb_dma_controller), GFP_KERNEL);
+	controller = kzalloc(sizeof(*controller), GFP_KERNEL);
 	if (!controller)
 		return NULL;
 
-	controller->bChannelCount = MUSB_HSDMA_CHANNELS;
-	controller->pDmaPrivate = musb;
-	controller->pCoreBase = pCoreBase;
+	controller->channel_count = MUSB_HSDMA_CHANNELS;
+	controller->private_data = musb;
+	controller->base = base;
 
-	controller->Controller.start = dma_controller_start;
-	controller->Controller.stop = dma_controller_stop;
-	controller->Controller.channel_alloc = dma_channel_allocate;
-	controller->Controller.channel_release = dma_channel_release;
-	controller->Controller.channel_program = dma_channel_program;
-	controller->Controller.channel_abort = dma_channel_abort;
+	controller->controller.start = dma_controller_start;
+	controller->controller.stop = dma_controller_stop;
+	controller->controller.channel_alloc = dma_channel_allocate;
+	controller->controller.channel_release = dma_channel_release;
+	controller->controller.channel_program = dma_channel_program;
+	controller->controller.channel_abort = dma_channel_abort;
 
 	if (request_irq(irq, dma_controller_irq, IRQF_DISABLED,
-			musb->controller->bus_id, &controller->Controller)) {
+			musb->controller->bus_id, &controller->controller)) {
 		dev_err(dev, "request_irq %d failed!\n", irq);
-		dma_controller_destroy(&controller->Controller);
+		dma_controller_destroy(&controller->controller);
+
 		return NULL;
 	}
 
 	controller->irq = irq;
 
-	return &controller->Controller;
+	return &controller->controller;
 }
diff --git a/scripts/Makefile.fwinst b/scripts/Makefile.fwinst
index 6bf8e87..fb20532 100644
--- a/scripts/Makefile.fwinst
+++ b/scripts/Makefile.fwinst
@@ -37,7 +37,7 @@ install-all-dirs: $(installed-fw-dirs)
 	@true
 
 quiet_cmd_install = INSTALL $(subst $(srctree)/,,$@)
-      cmd_install = $(INSTALL) -m0644 $< $@
+      cmd_install = $(INSTALL) -m 0644 $< $@
 
 $(installed-fw-dirs):
 	$(call cmd,mkdir)
Make hsmmc use omap_ctrl_read/write and existing defines

Signed-off-by: Tony Lindgren <tony@atomide.com>
---
 arch/arm/mach-omap2/hsmmc.c               |  116 +++++++++++++++-------------
 arch/arm/plat-omap/include/mach/control.h |   17 ++++
 2 files changed, 79 insertions(+), 54 deletions(-)

diff --git a/arch/arm/mach-omap2/hsmmc.c b/arch/arm/mach-omap2/hsmmc.c
index b1b18e3..b5ef975 100644
--- a/arch/arm/mach-omap2/hsmmc.c
+++ b/arch/arm/mach-omap2/hsmmc.c
@@ -19,6 +19,7 @@
 #include <linux/i2c/twl4030.h>
 
 #include <mach/hardware.h>
+#include <mach/control.h>
 #include <mach/mmc.h>
 #include <mach/board.h>
 
@@ -35,16 +36,22 @@
 #define VSEL_S2_CLR		0x40
 #define GPIO_0_BIT_POS		(1 << 0)
 
-#define OMAP2_CONTROL_DEVCONF0	0x48002274
-#define OMAP2_CONTROL_DEVCONF1	0x490022E8
-
-#define OMAP2_CONTROL_DEVCONF0_LBCLK	(1 << 24)
-#define OMAP2_CONTROL_DEVCONF1_ACTOV	(1 << 31)
-
-#define OMAP2_CONTROL_PBIAS_VMODE	(1 << 0)
-#define OMAP2_CONTROL_PBIAS_PWRDNZ	(1 << 1)
-#define OMAP2_CONTROL_PBIAS_SCTRL	(1 << 2)
+static u16 control_pbias_offset;
 
+static struct hsmmc_controller {
+	u16		control_devconf_offset;
+	u32		devconf_loopback_clock;
+	int		mmc1_cd_gpio;
+} hsmmc[] = {
+	{
+		.control_devconf_offset		= OMAP2_CONTROL_DEVCONF0,
+		.devconf_loopback_clock		= OMAP2_MMCSDIO1ADPCLKISEL,
+	},
+	{
+		/* control_devconf_offset set dynamically */
+		.devconf_loopback_clock		= OMAP2_MMCSDIO2ADPCLKISEL,
+	},
+};
 
 static const int mmc1_cd_gpio = OMAP_MAX_GPIO_LINES;		/* HACK!! */
 
@@ -140,53 +147,45 @@ static int hsmmc_resume(struct device *dev, int slot)
 
 #endif
 
-static int hsmmc_set_power(struct device *dev, int slot, int power_on,
+static int hsmmc1_set_power(struct device *dev, int slot, int power_on,
 				int vdd)
 {
-	u32 vdd_sel = 0, devconf = 0, reg = 0;
+	u32 reg;
 	int ret = 0;
-
-	/* REVISIT: Using address directly till the control.h defines
-	 * are settled.
-	 */
-#if defined(CONFIG_ARCH_OMAP2430)
-	#define OMAP2_CONTROL_PBIAS 0x490024A0
-#else
-	#define OMAP2_CONTROL_PBIAS 0x48002520
-#endif
+	u16 control_devconf_offset = hsmmc[0].control_devconf_offset;
 
 	if (power_on) {
-		if (cpu_is_omap24xx())
-			devconf = omap_readl(OMAP2_CONTROL_DEVCONF1);
-		else
-			devconf = omap_readl(OMAP2_CONTROL_DEVCONF0);
+		u32 vdd_sel = 0;
 
 		switch (1 << vdd) {
 		case MMC_VDD_33_34:
 		case MMC_VDD_32_33:
 			vdd_sel = VSEL_3V;
-			if (cpu_is_omap24xx())
-				devconf |= OMAP2_CONTROL_DEVCONF1_ACTOV;
 			break;
 		case MMC_VDD_165_195:
 			vdd_sel = VSEL_18V;
-			if (cpu_is_omap24xx())
-				devconf &= ~OMAP2_CONTROL_DEVCONF1_ACTOV;
 		}
 
-		if (cpu_is_omap24xx())
-			omap_writel(devconf, OMAP2_CONTROL_DEVCONF1);
-		else
-			omap_writel(devconf | OMAP2_CONTROL_DEVCONF0_LBCLK,
-				    OMAP2_CONTROL_DEVCONF0);
+		if (cpu_is_omap2430()) {
+			reg = omap_ctrl_readl(OMAP243X_CONTROL_DEVCONF1);
+			if (vdd_sel == VSEL_3V)
+				reg |= OMAP243X_MMC1_ACTIVE_OVERWRITE;
+			else
+				reg &= ~OMAP243X_MMC1_ACTIVE_OVERWRITE;
+			omap_ctrl_writel(reg, OMAP243X_CONTROL_DEVCONF1);
+		}
 
-		reg = omap_readl(OMAP2_CONTROL_PBIAS);
-		reg |= OMAP2_CONTROL_PBIAS_SCTRL;
-		omap_writel(reg, OMAP2_CONTROL_PBIAS);
+		/* REVISIT: Loop back clock not needed for 2430? */
+		if (!cpu_is_omap2430()) {
+			reg = omap_ctrl_readl(control_devconf_offset);
+			reg |= OMAP2_MMCSDIO1ADPCLKISEL;
+			omap_ctrl_writel(reg, control_devconf_offset);
+		}
 
-		reg = omap_readl(OMAP2_CONTROL_PBIAS);
-		reg &= ~OMAP2_CONTROL_PBIAS_PWRDNZ;
-		omap_writel(reg, OMAP2_CONTROL_PBIAS);
+		reg = omap_ctrl_readl(control_pbias_offset);
+		reg |= OMAP2_PBIASSPEEDCTRL0;
+		reg &= ~OMAP2_PBIASLITEPWRDNZ0;
+		omap_ctrl_writel(reg, control_pbias_offset);
 
 		ret = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
 						P1_DEV_GRP, VMMC1_DEV_GRP);
@@ -198,15 +197,16 @@ static int hsmmc_set_power(struct device *dev, int slot, int power_on,
 		if (ret)
 			goto err;
 
+		/* 100ms delay required for PBIAS configuration */
 		msleep(100);
-		reg = omap_readl(OMAP2_CONTROL_PBIAS);
-		reg |= (OMAP2_CONTROL_PBIAS_SCTRL |
-			OMAP2_CONTROL_PBIAS_PWRDNZ);
+
+		reg = omap_ctrl_readl(control_pbias_offset);
+		reg |= (OMAP2_PBIASLITEPWRDNZ0 | OMAP2_PBIASSPEEDCTRL0);
 		if (vdd_sel == VSEL_18V)
-			reg &= ~OMAP2_CONTROL_PBIAS_VMODE;
+			reg &= ~OMAP2_PBIASLITEVMODE0;
 		else
-			reg |= OMAP2_CONTROL_PBIAS_VMODE;
-		omap_writel(reg, OMAP2_CONTROL_PBIAS);
+			reg |= OMAP2_PBIASLITEVMODE0;
+		omap_ctrl_writel(reg, control_pbias_offset);
 
 		return ret;
 
@@ -214,9 +214,9 @@ static int hsmmc_set_power(struct device *dev, int slot, int power_on,
 		/* Power OFF */
 
 		/* For MMC1, Toggle PBIAS before every power up sequence */
-		reg = omap_readl(OMAP2_CONTROL_PBIAS);
-		reg &= ~OMAP2_CONTROL_PBIAS_PWRDNZ;
-		omap_writel(reg, OMAP2_CONTROL_PBIAS);
+		reg = omap_ctrl_readl(control_pbias_offset);
+		reg &= ~OMAP2_PBIASLITEPWRDNZ0;
+		omap_ctrl_writel(reg, control_pbias_offset);
 
 		ret = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
 						LDO_CLR, VMMC1_DEV_GRP);
@@ -230,11 +230,11 @@ static int hsmmc_set_power(struct device *dev, int slot, int power_on,
 
 		/* 100ms delay required for PBIAS configuration */
 		msleep(100);
-		reg = omap_readl(OMAP2_CONTROL_PBIAS);
-		reg |= (OMAP2_CONTROL_PBIAS_VMODE |
-			OMAP2_CONTROL_PBIAS_PWRDNZ |
-			OMAP2_CONTROL_PBIAS_SCTRL);
-		omap_writel(reg, OMAP2_CONTROL_PBIAS);
+
+		reg = omap_ctrl_readl(control_pbias_offset);
+		reg |= (OMAP2_PBIASSPEEDCTRL0 | OMAP2_PBIASLITEPWRDNZ0 |
+			OMAP2_PBIASLITEVMODE0);
+		omap_ctrl_writel(reg, control_pbias_offset);
 	}
 
 	return 0;
@@ -254,7 +254,7 @@ static struct omap_mmc_platform_data mmc1_data = {
 	.dma_mask			= 0xffffffff,
 	.slots[0] = {
 		.wire4			= 1,
-		.set_power		= hsmmc_set_power,
+		.set_power		= hsmmc1_set_power,
 		.ocr_mask		= MMC_VDD_32_33 | MMC_VDD_33_34 |
 						MMC_VDD_165_195,
 		.name			= "first slot",
@@ -268,6 +268,14 @@ static struct omap_mmc_platform_data *hsmmc_data[OMAP34XX_NR_MMC];
 
 void __init hsmmc_init(void)
 {
+	if (cpu_is_omap2430()) {
+		control_pbias_offset = OMAP243X_CONTROL_PBIAS_LITE;
+		hsmmc[1].control_devconf_offset = OMAP243X_CONTROL_DEVCONF1;
+	} else {
+		control_pbias_offset = OMAP343X_CONTROL_PBIAS_LITE;
+		hsmmc[1].control_devconf_offset = OMAP343X_CONTROL_DEVCONF1;
+	}
+
 	hsmmc_data[0] = &mmc1_data;
 	omap2_init_mmc(hsmmc_data, OMAP34XX_NR_MMC);
 }
diff --git a/arch/arm/plat-omap/include/mach/control.h b/arch/arm/plat-omap/include/mach/control.h
index 9ca0e08..b950e1e 100644
--- a/arch/arm/plat-omap/include/mach/control.h
+++ b/arch/arm/plat-omap/include/mach/control.h
@@ -74,6 +74,7 @@
 #define OMAP243X_CONTROL_IVA2_BOOTADDR	(OMAP2_CONTROL_GENERAL + 0x0190)
 #define OMAP243X_CONTROL_IVA2_BOOTMOD	(OMAP2_CONTROL_GENERAL + 0x0194)
 #define OMAP243X_CONTROL_IVA2_GEMCFG	(OMAP2_CONTROL_GENERAL + 0x0198)
+#define OMAP243X_CONTROL_PBIAS_LITE	(OMAP2_CONTROL_GENERAL + 0x0230)
 
 /* 24xx-only CONTROL_GENERAL register offsets */
 #define OMAP24XX_CONTROL_DEBOBS		(OMAP2_CONTROL_GENERAL + 0x0000)
@@ -149,6 +150,7 @@
 #define OMAP343X_CONTROL_FUSE_SR	(OMAP2_CONTROL_GENERAL + 0x0130)
 #define OMAP343X_CONTROL_IVA2_BOOTADDR	(OMAP2_CONTROL_GENERAL + 0x0190)
 #define OMAP343X_CONTROL_IVA2_BOOTMOD	(OMAP2_CONTROL_GENERAL + 0x0194)
+#define OMAP343X_CONTROL_PBIAS_LITE	(OMAP2_CONTROL_GENERAL + 0x02b0)
 #define OMAP343X_CONTROL_TEMP_SENSOR	(OMAP2_CONTROL_GENERAL + 0x02b4)
 
 /*
@@ -163,11 +165,14 @@
  * and the security mode (secure, non-secure, don't care)
  */
 /* CONTROL_DEVCONF0 bits */
+#define OMAP2_MMCSDIO1ADPCLKISEL	(1 << 24) /* MMC1 loop back clock */
 #define OMAP24XX_USBSTANDBYCTRL		(1 << 15)
 #define OMAP2_MCBSP2_CLKS_MASK		(1 << 6)
 #define OMAP2_MCBSP1_CLKS_MASK		(1 << 2)
 
 /* CONTROL_DEVCONF1 bits */
+#define OMAP243X_MMC1_ACTIVE_OVERWRITE	(1 << 31)
+#define OMAP2_MMCSDIO2ADPCLKISEL	(1 << 6) /* MMC2 loop back clock */
 #define OMAP2_MCBSP5_CLKS_MASK		(1 << 4) /* > 242x */
 #define OMAP2_MCBSP4_CLKS_MASK		(1 << 2) /* > 242x */
 #define OMAP2_MCBSP3_CLKS_MASK		(1 << 0) /* > 242x */
@@ -191,6 +196,18 @@
 #define OMAP343X_SR1_SENPENABLE_MASK	(0x3 << 0)
 #define OMAP343X_SR1_SENPENABLE_SHIFT	0
 
+/* CONTROL_PBIAS_LITE bits */
+#define OMAP343X_PBIASLITESUPPLY_HIGH1	(1 << 15)
+#define OMAP343X_PBIASLITEVMODEERROR1	(1 << 11)
+#define OMAP343X_PBIASSPEEDCTRL1	(1 << 10)
+#define OMAP343X_PBIASLITEPWRDNZ1	(1 << 9)
+#define OMAP343X_PBIASLITEVMODE1	(1 << 8)
+#define OMAP343X_PBIASLITESUPPLY_HIGH0	(1 << 7)
+#define OMAP343X_PBIASLITEVMODEERROR0	(1 << 3)
+#define OMAP2_PBIASSPEEDCTRL0		(1 << 2)
+#define OMAP2_PBIASLITEPWRDNZ0		(1 << 1)
+#define OMAP2_PBIASLITEVMODE0		(1 << 0)
+
 #ifndef __ASSEMBLY__
 #if defined(CONFIG_ARCH_OMAP2) || defined(CONFIG_ARCH_OMAP3)
 extern void __iomem *omap_ctrl_base_get(void);
-- 
Fix voltage defines, make card detect gpio controller specific

Signed-off-by: Tony Lindgren <tony@atomide.com>
---
 arch/arm/mach-omap2/hsmmc.c |   60 ++++++++++++++++++++++++------------------
 1 files changed, 34 insertions(+), 26 deletions(-)

diff --git a/arch/arm/mach-omap2/hsmmc.c b/arch/arm/mach-omap2/hsmmc.c
index b5ef975..f711d7b 100644
--- a/arch/arm/mach-omap2/hsmmc.c
+++ b/arch/arm/mach-omap2/hsmmc.c
@@ -25,27 +25,32 @@
 
 #if defined(CONFIG_MMC_OMAP_HS) || defined(CONFIG_MMC_OMAP_HS_MODULE)
 
-#define VMMC1_DEV_GRP		0x27
-#define P1_DEV_GRP		0x20
-#define VMMC1_DEDICATED		0x2A
-#define VSEL_3V			0x02
-#define VSEL_18V		0x00
 #define TWL_GPIO_IMR1A		0x1C
 #define TWL_GPIO_ISR1A		0x19
 #define LDO_CLR			0x00
 #define VSEL_S2_CLR		0x40
 #define GPIO_0_BIT_POS		(1 << 0)
 
+#define VMMC1_DEV_GRP		0x27
+#define VMMC1_DEV_GRP_P1	0x20
+#define VMMC1_DEDICATED		0x2A
+#define VMMC1_CLR		0x00
+#define VMMC1_315V		0x03
+#define VMMC1_300V		0x02
+#define VMMC1_285V		0x01
+#define VMMC1_185V		0x00
+
 static u16 control_pbias_offset;
 
 static struct hsmmc_controller {
 	u16		control_devconf_offset;
 	u32		devconf_loopback_clock;
-	int		mmc1_cd_gpio;
+	int		card_detect_gpio;
 } hsmmc[] = {
 	{
 		.control_devconf_offset		= OMAP2_CONTROL_DEVCONF0,
 		.devconf_loopback_clock		= OMAP2_MMCSDIO1ADPCLKISEL,
+		.card_detect_gpio		= OMAP_MAX_GPIO_LINES,
 	},
 	{
 		/* control_devconf_offset set dynamically */
@@ -53,24 +58,22 @@ static struct hsmmc_controller {
 	},
 };
 
-static const int mmc1_cd_gpio = OMAP_MAX_GPIO_LINES;		/* HACK!! */
-
-static int hsmmc_card_detect(int irq)
+static int hsmmc1_card_detect(int irq)
 {
-	return gpio_get_value_cansleep(mmc1_cd_gpio);
+	return gpio_get_value_cansleep(hsmmc[0].card_detect_gpio);
 }
 
 /*
  * MMC Slot Initialization.
  */
-static int hsmmc_late_init(struct device *dev)
+static int hsmmc1_late_init(struct device *dev)
 {
 	int ret = 0;
 
 	/*
 	 * Configure TWL4030 GPIO parameters for MMC hotplug irq
 	 */
-	ret = gpio_request(mmc1_cd_gpio, "mmc0_cd");
+	ret = gpio_request(hsmmc[0].card_detect_gpio, "mmc0_cd");
 	if (ret)
 		goto err;
 
@@ -85,9 +88,9 @@ err:
 	return ret;
 }
 
-static void hsmmc_cleanup(struct device *dev)
+static void hsmmc1_cleanup(struct device *dev)
 {
-	gpio_free(mmc1_cd_gpio);
+	gpio_free(hsmmc[0].card_detect_gpio);
 }
 
 #ifdef CONFIG_PM
@@ -125,7 +128,7 @@ err:
 	return ret;
 }
 
-static int hsmmc_suspend(struct device *dev, int slot)
+static int hsmmc1_suspend(struct device *dev, int slot)
 {
 	int ret = 0;
 
@@ -135,7 +138,7 @@ static int hsmmc_suspend(struct device *dev, int slot)
 	return ret;
 }
 
-static int hsmmc_resume(struct device *dev, int slot)
+static int hsmmc1_resume(struct device *dev, int slot)
 {
 	int ret = 0;
 
@@ -160,15 +163,20 @@ static int hsmmc1_set_power(struct device *dev, int slot, int power_on,
 		switch (1 << vdd) {
 		case MMC_VDD_33_34:
 		case MMC_VDD_32_33:
-			vdd_sel = VSEL_3V;
+		case MMC_VDD_31_32:
+		case MMC_VDD_30_31:
+			vdd_sel = VMMC1_315V;
+			break;
+		case MMC_VDD_29_30:
+			vdd_sel = VMMC1_300V;
 			break;
 		case MMC_VDD_165_195:
-			vdd_sel = VSEL_18V;
+			vdd_sel = VMMC1_185V;
 		}
 
 		if (cpu_is_omap2430()) {
 			reg = omap_ctrl_readl(OMAP243X_CONTROL_DEVCONF1);
-			if (vdd_sel == VSEL_3V)
+			if (vdd_sel >= VMMC1_300V)
 				reg |= OMAP243X_MMC1_ACTIVE_OVERWRITE;
 			else
 				reg &= ~OMAP243X_MMC1_ACTIVE_OVERWRITE;
@@ -188,7 +196,7 @@ static int hsmmc1_set_power(struct device *dev, int slot, int power_on,
 		omap_ctrl_writel(reg, control_pbias_offset);
 
 		ret = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
-						P1_DEV_GRP, VMMC1_DEV_GRP);
+						VMMC1_DEV_GRP_P1, VMMC1_DEV_GRP);
 		if (ret)
 			goto err;
 
@@ -202,7 +210,7 @@ static int hsmmc1_set_power(struct device *dev, int slot, int power_on,
 
 		reg = omap_ctrl_readl(control_pbias_offset);
 		reg |= (OMAP2_PBIASLITEPWRDNZ0 | OMAP2_PBIASSPEEDCTRL0);
-		if (vdd_sel == VSEL_18V)
+		if (vdd_sel == VMMC1_185V)
 			reg &= ~OMAP2_PBIASLITEVMODE0;
 		else
 			reg |= OMAP2_PBIASLITEVMODE0;
@@ -245,11 +253,11 @@ err:
 
 static struct omap_mmc_platform_data mmc1_data = {
 	.nr_slots			= 1,
-	.init				= hsmmc_late_init,
-	.cleanup			= hsmmc_cleanup,
+	.init				= hsmmc1_late_init,
+	.cleanup			= hsmmc1_cleanup,
 #ifdef CONFIG_PM
-	.suspend			= hsmmc_suspend,
-	.resume				= hsmmc_resume,
+	.suspend			= hsmmc1_suspend,
+	.resume				= hsmmc1_resume,
 #endif
 	.dma_mask			= 0xffffffff,
 	.slots[0] = {
@@ -260,7 +268,7 @@ static struct omap_mmc_platform_data mmc1_data = {
 		.name			= "first slot",
 
 		.card_detect_irq        = TWL4030_GPIO_IRQ_NO(0),
-		.card_detect            = hsmmc_card_detect,
+		.card_detect            = hsmmc1_card_detect,
 	},
 };
 
-- 
Add support for the second controller hopefully in a generic way.
Also put the twl4030 specific voltage configuration into a separate
function.

Signed-off-by: Tony Lindgren <tony@atomide.com>
---
 arch/arm/mach-omap2/board-2430sdp.c      |    4 +-
 arch/arm/mach-omap2/board-3430sdp.c      |    4 +-
 arch/arm/mach-omap2/board-ldp.c          |    4 +-
 arch/arm/mach-omap2/board-omap2evm.c     |    4 +-
 arch/arm/mach-omap2/board-omap3beagle.c  |    4 +-
 arch/arm/mach-omap2/board-omap3evm.c     |    4 +-
 arch/arm/mach-omap2/board-omap3pandora.c |    4 +-
 arch/arm/mach-omap2/board-overo.c        |    4 +-
 arch/arm/mach-omap2/hsmmc.c              |  192 +++++++++++++++++++++---------
 arch/arm/plat-omap/include/mach/hsmmc.h  |   35 ------
 arch/arm/plat-omap/include/mach/mmc.h    |    9 ++-
 11 files changed, 160 insertions(+), 108 deletions(-)
 delete mode 100644 arch/arm/plat-omap/include/mach/hsmmc.h

diff --git a/arch/arm/mach-omap2/board-2430sdp.c b/arch/arm/mach-omap2/board-2430sdp.c
index cea2540..8532ef3 100644
--- a/arch/arm/mach-omap2/board-2430sdp.c
+++ b/arch/arm/mach-omap2/board-2430sdp.c
@@ -36,7 +36,7 @@
 #include <mach/mux.h>
 #include <mach/board.h>
 #include <mach/usb-musb.h>
-#include <mach/hsmmc.h>
+#include <mach/mmc.h>
 #include <mach/common.h>
 #include <mach/keypad.h>
 #include <mach/gpmc.h>
@@ -404,7 +404,7 @@ static void __init omap_2430sdp_init(void)
 	spi_register_board_info(sdp2430_spi_board_info,
 				ARRAY_SIZE(sdp2430_spi_board_info));
 	ads7846_dev_init();
-	hsmmc_init();
+	hsmmc_init(HSMMC1);
 
 	/* turn off secondary LCD backlight */
 	omap_set_gpio_direction(SECONDARY_LCD_GPIO, 0);
diff --git a/arch/arm/mach-omap2/board-3430sdp.c b/arch/arm/mach-omap2/board-3430sdp.c
index 8773698..0221b66 100644
--- a/arch/arm/mach-omap2/board-3430sdp.c
+++ b/arch/arm/mach-omap2/board-3430sdp.c
@@ -35,7 +35,7 @@
 #include <mach/board.h>
 #include <mach/usb-musb.h>
 #include <mach/usb-ehci.h>
-#include <mach/hsmmc.h>
+#include <mach/mmc.h>
 #include <mach/common.h>
 #include <mach/keypad.h>
 #include <mach/dma.h>
@@ -465,7 +465,7 @@ static void __init omap_3430sdp_init(void)
 	omap_serial_init();
 	usb_musb_init();
 	usb_ehci_init();
-	hsmmc_init();
+	hsmmc_init(HSMMC1 | HSMMC2);
 }
 
 static void __init omap_3430sdp_map_io(void)
diff --git a/arch/arm/mach-omap2/board-ldp.c b/arch/arm/mach-omap2/board-ldp.c
index d4d4e90..387bd41 100644
--- a/arch/arm/mach-omap2/board-ldp.c
+++ b/arch/arm/mach-omap2/board-ldp.c
@@ -34,7 +34,7 @@
 #include <mach/board.h>
 #include <mach/common.h>
 #include <mach/gpmc.h>
-#include <mach/hsmmc.h>
+#include <mach/mmc.h>
 #include <mach/usb-musb.h>
 
 #include <asm/io.h>
@@ -341,7 +341,7 @@ static void __init omap_ldp_init(void)
 	ads7846_dev_init();
 	omap_serial_init();
 	usb_musb_init();
-	hsmmc_init();
+	hsmmc_init(HSMMC1);
 }
 
 static void __init omap_ldp_map_io(void)
diff --git a/arch/arm/mach-omap2/board-omap2evm.c b/arch/arm/mach-omap2/board-omap2evm.c
index d284551..68aebe7 100644
--- a/arch/arm/mach-omap2/board-omap2evm.c
+++ b/arch/arm/mach-omap2/board-omap2evm.c
@@ -34,7 +34,7 @@
 #include <mach/gpio.h>
 #include <mach/board.h>
 #include <mach/common.h>
-#include <mach/hsmmc.h>
+#include <mach/mmc.h>
 #include <mach/keypad.h>
 #include <mach/gpmc.h>
 #include <mach/nand.h>
@@ -347,7 +347,7 @@ static void __init omap2_evm_init(void)
 	spi_register_board_info(omap2evm_spi_board_info,
 				ARRAY_SIZE(omap2evm_spi_board_info));
 	omap_serial_init();
-	hsmmc_init();
+	hsmmc_init(HSMMC1);
 	omap2evm_flash_init();
 	ads7846_dev_init();
 }
diff --git a/arch/arm/mach-omap2/board-omap3beagle.c b/arch/arm/mach-omap2/board-omap3beagle.c
index ce6c7b4..062a28b 100644
--- a/arch/arm/mach-omap2/board-omap3beagle.c
+++ b/arch/arm/mach-omap2/board-omap3beagle.c
@@ -37,7 +37,7 @@
 #include <mach/board.h>
 #include <mach/usb-musb.h>
 #include <mach/usb-ehci.h>
-#include <mach/hsmmc.h>
+#include <mach/mmc.h>
 #include <mach/common.h>
 #include <mach/gpmc.h>
 #include <mach/nand.h>
@@ -309,7 +309,7 @@ static void __init omap3_beagle_init(void)
 	omap_cfg_reg(AH8_34XX_GPIO29);
 	gpio_request(29, "mmc0_wp");
 	gpio_direction_input(29);
-	hsmmc_init();
+	hsmmc_init(HSMMC1);
 
 	omap_cfg_reg(J25_34XX_GPIO170);
 	gpio_request(170, "DVI_nPD");
diff --git a/arch/arm/mach-omap2/board-omap3evm.c b/arch/arm/mach-omap2/board-omap3evm.c
index a72772f..614fa02 100644
--- a/arch/arm/mach-omap2/board-omap3evm.c
+++ b/arch/arm/mach-omap2/board-omap3evm.c
@@ -32,7 +32,7 @@
 #include <mach/gpio.h>
 #include <mach/keypad.h>
 #include <mach/board.h>
-#include <mach/hsmmc.h>
+#include <mach/mmc.h>
 #include <mach/usb-musb.h>
 #include <mach/usb-ehci.h>
 #include <mach/common.h>
@@ -245,7 +245,7 @@ static void __init omap3_evm_init(void)
 				ARRAY_SIZE(omap3evm_spi_board_info));
 
 	omap_serial_init();
-	hsmmc_init();
+	hsmmc_init(HSMMC1);
 	usb_musb_init();
 	usb_ehci_init();
 	omap3evm_flash_init();
diff --git a/arch/arm/mach-omap2/board-omap3pandora.c b/arch/arm/mach-omap2/board-omap3pandora.c
index f4180a0..ee001bb 100644
--- a/arch/arm/mach-omap2/board-omap3pandora.c
+++ b/arch/arm/mach-omap2/board-omap3pandora.c
@@ -41,7 +41,7 @@
 #include <mach/gpio.h>
 #include <mach/gpmc.h>
 #include <mach/hardware.h>
-#include <mach/hsmmc.h>
+#include <mach/mmc.h>
 #include <mach/nand.h>
 #include <mach/usb-ehci.h>
 #include <mach/usb-musb.h>
@@ -208,7 +208,7 @@ static void __init omap3pandora_init(void)
 	omap_board_config = omap3pandora_config;
 	omap_board_config_size = ARRAY_SIZE(omap3pandora_config);
 	omap_serial_init();
-	hsmmc_init();
+	hsmmc_init(HSMMC1);
 	usb_musb_init();
 	usb_ehci_init();
 	omap3pandora_flash_init();
diff --git a/arch/arm/mach-omap2/board-overo.c b/arch/arm/mach-omap2/board-overo.c
index b0e5cec..a4bd804 100644
--- a/arch/arm/mach-omap2/board-overo.c
+++ b/arch/arm/mach-omap2/board-overo.c
@@ -42,7 +42,7 @@
 #include <mach/gpio.h>
 #include <mach/gpmc.h>
 #include <mach/hardware.h>
-#include <mach/hsmmc.h>
+#include <mach/mmc.h>
 #include <mach/nand.h>
 #include <mach/usb-ehci.h>
 #include <mach/usb-musb.h>
@@ -212,7 +212,7 @@ static void __init overo_init(void)
 	omap_board_config = overo_config;
 	omap_board_config_size = ARRAY_SIZE(overo_config);
 	omap_serial_init();
-	hsmmc_init();
+	hsmmc_init(HSMMC1);
 	usb_musb_init();
 	usb_ehci_init();
 	overo_flash_init();
diff --git a/arch/arm/mach-omap2/hsmmc.c b/arch/arm/mach-omap2/hsmmc.c
index f711d7b..23cbdf6 100644
--- a/arch/arm/mach-omap2/hsmmc.c
+++ b/arch/arm/mach-omap2/hsmmc.c
@@ -32,13 +32,23 @@
 #define GPIO_0_BIT_POS		(1 << 0)
 
 #define VMMC1_DEV_GRP		0x27
-#define VMMC1_DEV_GRP_P1	0x20
-#define VMMC1_DEDICATED		0x2A
 #define VMMC1_CLR		0x00
 #define VMMC1_315V		0x03
 #define VMMC1_300V		0x02
 #define VMMC1_285V		0x01
 #define VMMC1_185V		0x00
+#define VMMC1_DEDICATED		0x2A
+
+#define VMMC2_DEV_GRP		0x2B
+#define VMMC2_CLR		0x40
+#define VMMC2_315V		0x0c
+#define VMMC2_300V		0x0b
+#define VMMC2_285V		0x0a
+#define VMMC2_260V		0x08
+#define VMMC2_185V		0x06
+#define VMMC2_DEDICATED		0x2E
+
+#define VMMC_DEV_GRP_P1		0x20
 
 static u16 control_pbias_offset;
 
@@ -46,17 +56,23 @@ static struct hsmmc_controller {
 	u16		control_devconf_offset;
 	u32		devconf_loopback_clock;
 	int		card_detect_gpio;
+	u8		twl_vmmc_dev_grp;
+	u8		twl_mmc_dedicated;
 } hsmmc[] = {
 	{
 		.control_devconf_offset		= OMAP2_CONTROL_DEVCONF0,
 		.devconf_loopback_clock		= OMAP2_MMCSDIO1ADPCLKISEL,
 		.card_detect_gpio		= OMAP_MAX_GPIO_LINES,
+		.twl_vmmc_dev_grp		= VMMC1_DEV_GRP,
+		.twl_mmc_dedicated		= VMMC1_DEDICATED,
 	},
 	{
 		/* control_devconf_offset set dynamically */
 		.devconf_loopback_clock		= OMAP2_MMCSDIO2ADPCLKISEL,
+		.twl_vmmc_dev_grp		= VMMC2_DEV_GRP,
+		.twl_mmc_dedicated		= VMMC2_DEDICATED,
 	},
-};
+ };
 
 static int hsmmc1_card_detect(int irq)
 {
@@ -96,7 +112,7 @@ static void hsmmc1_cleanup(struct device *dev)
 #ifdef CONFIG_PM
 
 /*
- * To mask and unmask MMC Card Detect Interrupt
+ * Mask and unmask MMC Card Detect Interrupt
  * mask : 1
  * unmask : 0
  */
@@ -150,33 +166,88 @@ static int hsmmc1_resume(struct device *dev, int slot)
 
 #endif
 
+/*
+ * Sets the MMC voltage in twl4030
+ */
+static int hsmmc_twl_set_voltage(struct hsmmc_controller *c, int vdd)
+{
+	int ret;
+	u8 vmmc, dev_grp_val;
+
+	switch (1 << vdd) {
+	case MMC_VDD_35_36:
+	case MMC_VDD_34_35:
+	case MMC_VDD_33_34:
+	case MMC_VDD_32_33:
+	case MMC_VDD_31_32:
+	case MMC_VDD_30_31:
+		if (c->twl_vmmc_dev_grp == VMMC1_DEV_GRP)
+			vmmc = VMMC1_315V;
+		else
+			vmmc = VMMC2_315V;
+		break;
+	case MMC_VDD_29_30:
+		if (c->twl_vmmc_dev_grp == VMMC1_DEV_GRP)
+			vmmc = VMMC1_315V;
+		else
+			vmmc = VMMC2_300V;
+		break;
+	case MMC_VDD_27_28:
+	case MMC_VDD_26_27:
+		if (c->twl_vmmc_dev_grp == VMMC1_DEV_GRP)
+			vmmc = VMMC1_285V;
+		else
+			vmmc = VMMC2_285V;
+		break;
+	case MMC_VDD_25_26:
+	case MMC_VDD_24_25:
+	case MMC_VDD_23_24:
+	case MMC_VDD_22_23:
+	case MMC_VDD_21_22:
+	case MMC_VDD_20_21:
+		if (c->twl_vmmc_dev_grp == VMMC1_DEV_GRP)
+			vmmc = VMMC1_285V;
+		else
+			vmmc = VMMC2_260V;
+		break;
+	case MMC_VDD_165_195:
+		if (c->twl_vmmc_dev_grp == VMMC1_DEV_GRP)
+			vmmc = VMMC1_185V;
+		else
+			vmmc = VMMC2_185V;
+		break;
+	default:
+		vmmc = 0;
+		break;
+	}
+
+	if (vmmc)
+		dev_grp_val = VMMC_DEV_GRP_P1;	/* Power up */
+	else
+		dev_grp_val = LDO_CLR;		/* Power down */
+
+	ret = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+					dev_grp_val, c->twl_vmmc_dev_grp);
+	if (ret)
+		return ret;
+
+	ret = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+						vmmc, c->twl_mmc_dedicated);
+
+	return ret;
+}
+
 static int hsmmc1_set_power(struct device *dev, int slot, int power_on,
 				int vdd)
 {
 	u32 reg;
 	int ret = 0;
-	u16 control_devconf_offset = hsmmc[0].control_devconf_offset;
+	struct hsmmc_controller *c = &hsmmc[0];
 
 	if (power_on) {
-		u32 vdd_sel = 0;
-
-		switch (1 << vdd) {
-		case MMC_VDD_33_34:
-		case MMC_VDD_32_33:
-		case MMC_VDD_31_32:
-		case MMC_VDD_30_31:
-			vdd_sel = VMMC1_315V;
-			break;
-		case MMC_VDD_29_30:
-			vdd_sel = VMMC1_300V;
-			break;
-		case MMC_VDD_165_195:
-			vdd_sel = VMMC1_185V;
-		}
-
 		if (cpu_is_omap2430()) {
 			reg = omap_ctrl_readl(OMAP243X_CONTROL_DEVCONF1);
-			if (vdd_sel >= VMMC1_300V)
+			if ((1 << vdd) >= MMC_VDD_30_31)
 				reg |= OMAP243X_MMC1_ACTIVE_OVERWRITE;
 			else
 				reg &= ~OMAP243X_MMC1_ACTIVE_OVERWRITE;
@@ -185,9 +256,9 @@ static int hsmmc1_set_power(struct device *dev, int slot, int power_on,
 
 		/* REVISIT: Loop back clock not needed for 2430? */
 		if (!cpu_is_omap2430()) {
-			reg = omap_ctrl_readl(control_devconf_offset);
+			reg = omap_ctrl_readl(c->control_devconf_offset);
 			reg |= OMAP2_MMCSDIO1ADPCLKISEL;
-			omap_ctrl_writel(reg, control_devconf_offset);
+			omap_ctrl_writel(reg, c->control_devconf_offset);
 		}
 
 		reg = omap_ctrl_readl(control_pbias_offset);
@@ -195,60 +266,53 @@ static int hsmmc1_set_power(struct device *dev, int slot, int power_on,
 		reg &= ~OMAP2_PBIASLITEPWRDNZ0;
 		omap_ctrl_writel(reg, control_pbias_offset);
 
-		ret = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
-						VMMC1_DEV_GRP_P1, VMMC1_DEV_GRP);
-		if (ret)
-			goto err;
-
-		ret = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
-						vdd_sel, VMMC1_DEDICATED);
-		if (ret)
-			goto err;
+		ret = hsmmc_twl_set_voltage(c, vdd);
 
 		/* 100ms delay required for PBIAS configuration */
 		msleep(100);
-
 		reg = omap_ctrl_readl(control_pbias_offset);
 		reg |= (OMAP2_PBIASLITEPWRDNZ0 | OMAP2_PBIASSPEEDCTRL0);
-		if (vdd_sel == VMMC1_185V)
+		if ((1 << vdd) <= MMC_VDD_165_195)
 			reg &= ~OMAP2_PBIASLITEVMODE0;
 		else
 			reg |= OMAP2_PBIASLITEVMODE0;
 		omap_ctrl_writel(reg, control_pbias_offset);
-
-		return ret;
-
 	} else {
-		/* Power OFF */
-
-		/* For MMC1, Toggle PBIAS before every power up sequence */
 		reg = omap_ctrl_readl(control_pbias_offset);
 		reg &= ~OMAP2_PBIASLITEPWRDNZ0;
 		omap_ctrl_writel(reg, control_pbias_offset);
 
-		ret = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
-						LDO_CLR, VMMC1_DEV_GRP);
-		if (ret)
-			goto err;
-
-		ret = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
-						VSEL_S2_CLR, VMMC1_DEDICATED);
-		if (ret)
-			goto err;
+		ret = hsmmc_twl_set_voltage(c, 0);
 
 		/* 100ms delay required for PBIAS configuration */
 		msleep(100);
-
 		reg = omap_ctrl_readl(control_pbias_offset);
 		reg |= (OMAP2_PBIASSPEEDCTRL0 | OMAP2_PBIASLITEPWRDNZ0 |
 			OMAP2_PBIASLITEVMODE0);
 		omap_ctrl_writel(reg, control_pbias_offset);
 	}
 
-	return 0;
+	return ret;
+}
 
-err:
-	return 1;
+static int hsmmc2_set_power(struct device *dev, int slot, int power_on, int vdd)
+{
+	int ret;
+
+	struct hsmmc_controller *c = &hsmmc[1];
+
+	if (power_on) {
+		u32 reg;
+
+		reg = omap_ctrl_readl(c->control_devconf_offset);
+		reg |= OMAP2_MMCSDIO2ADPCLKISEL;
+		omap_ctrl_writel(reg, c->control_devconf_offset);
+		ret = hsmmc_twl_set_voltage(c, vdd);
+	} else {
+		ret = hsmmc_twl_set_voltage(c, 0);
+	}
+
+	return ret;
 }
 
 static struct omap_mmc_platform_data mmc1_data = {
@@ -272,9 +336,20 @@ static struct omap_mmc_platform_data mmc1_data = {
 	},
 };
 
+static struct omap_mmc_platform_data mmc2_data = {
+	.nr_slots			= 1,
+	.slots[0] = {
+		.set_power		= hsmmc2_set_power,
+		.ocr_mask		= MMC_VDD_27_28 | MMC_VDD_28_29 |
+					  MMC_VDD_29_30 | MMC_VDD_30_31 |
+					  MMC_VDD_31_32 | MMC_VDD_32_33,
+		.name			= "second slot",
+	},
+};
+
 static struct omap_mmc_platform_data *hsmmc_data[OMAP34XX_NR_MMC];
 
-void __init hsmmc_init(void)
+void __init hsmmc_init(int controller_mask)
 {
 	if (cpu_is_omap2430()) {
 		control_pbias_offset = OMAP243X_CONTROL_PBIAS_LITE;
@@ -284,7 +359,12 @@ void __init hsmmc_init(void)
 		hsmmc[1].control_devconf_offset = OMAP343X_CONTROL_DEVCONF1;
 	}
 
-	hsmmc_data[0] = &mmc1_data;
+	if (controller_mask & HSMMC1)
+		hsmmc_data[0] = &mmc1_data;
+	if (controller_mask & HSMMC2)
+		hsmmc_data[1] = &mmc2_data;
+	if (controller_mask & HSMMC3)
+		pr_err("HSMMC: Unknown configuration for controller 3\n");
 	omap2_init_mmc(hsmmc_data, OMAP34XX_NR_MMC);
 }
 
diff --git a/arch/arm/plat-omap/include/mach/hsmmc.h b/arch/arm/plat-omap/include/mach/hsmmc.h
deleted file mode 100644
index 587e8ab..0000000
--- a/arch/arm/plat-omap/include/mach/hsmmc.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * include/asm-arm/arch-omap/hsmmc.h
- *
- * Hardware definitions for SD/MMC Controller on OMAP243x and OMAP34xx
- *
- * Initial creation by Felipe Balbi.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
- * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#ifndef __ASM_ARCH_OMAP_HSMMC_H
-#define __ASM_ARCH_OMAP_HSMMC_H
-
-extern void hsmmc_init(void);
-
-#endif /* __ASM_ARCH_OMAP_HSMMC_H */
-
diff --git a/arch/arm/plat-omap/include/mach/mmc.h b/arch/arm/plat-omap/include/mach/mmc.h
index 2f20789..5e8ac72 100644
--- a/arch/arm/plat-omap/include/mach/mmc.h
+++ b/arch/arm/plat-omap/include/mach/mmc.h
@@ -30,6 +30,9 @@
 #define OMAP2_MMC1_BASE		0x4809c000
 #define OMAP2_MMC2_BASE		0x480b4000
 #define OMAP3_MMC3_BASE		0x480ad000
+#define HSMMC3			(1 << 2)
+#define HSMMC2			(1 << 1)
+#define HSMMC1			(1 << 0)
 
 #define OMAP_MMC_MAX_SLOTS	2
 
@@ -127,7 +130,11 @@ static inline int omap_mmc_add(int id, unsigned long base, unsigned long size,
 #endif
 
 #if defined(CONFIG_MMC_OMAP_HS) || defined(CONFIG_MMC_OMAP_HS_MODULE)
-void __init hsmmc_init(void);
+void __init hsmmc_init(int controller_mask);
+#else
+static inline void hsmmc_init(void)
+{
+}
 #endif
 
 #endif
-- 
Misc clean-up for hsmmc init

Signed-off-by: Tony Lindgren <tony@atomide.com>
---
 arch/arm/mach-omap1/devices.c         |    2 +-
 arch/arm/mach-omap2/board-overo.c     |    2 ++
 arch/arm/mach-omap2/devices.c         |    2 +-
 arch/arm/mach-omap2/hsmmc.c           |   16 +++++-----------
 arch/arm/plat-omap/devices.c          |    2 +-
 arch/arm/plat-omap/include/mach/mmc.h |   12 ++++--------
 6 files changed, 14 insertions(+), 22 deletions(-)

diff --git a/arch/arm/mach-omap1/devices.c b/arch/arm/mach-omap1/devices.c
index 375a874..024dab1 100644
--- a/arch/arm/mach-omap1/devices.c
+++ b/arch/arm/mach-omap1/devices.c
@@ -102,7 +102,7 @@ static inline void omap_init_mbox(void) { }
 
 /*-------------------------------------------------------------------------*/
 
-#if	defined(CONFIG_MMC_OMAP) || defined(CONFIG_MMC_OMAP_MODULE)
+#if defined(CONFIG_MMC_OMAP) || defined(CONFIG_MMC_OMAP_MODULE)
 
 static inline void omap1_mmc_mux(struct omap_mmc_platform_data *mmc_controller,
 			int controller_nr)
diff --git a/arch/arm/mach-omap2/board-overo.c b/arch/arm/mach-omap2/board-overo.c
index a4bd804..4f0b5d4 100644
--- a/arch/arm/mach-omap2/board-overo.c
+++ b/arch/arm/mach-omap2/board-overo.c
@@ -26,6 +26,7 @@
 #include <linux/io.h>
 #include <linux/kernel.h>
 #include <linux/platform_device.h>
+#include <linux/i2c/twl4030.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
@@ -144,6 +145,7 @@ static void __init overo_flash_init(void)
 static struct omap_uart_config overo_uart_config __initdata = {
 	.enabled_uarts	= ((1 << 0) | (1 << 1) | (1 << 2)),
 };
+
 static struct twl4030_gpio_platform_data overo_gpio_data = {
 	.gpio_base	= OMAP_MAX_GPIO_LINES,
 	.irq_base	= TWL4030_GPIO_IRQ_BASE,
diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index 32550a5..0dd8b96 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -358,7 +358,7 @@ static inline void omap_init_sha1_md5(void) { }
 
 /*-------------------------------------------------------------------------*/
 
-#if	defined(CONFIG_MMC_OMAP) || defined(CONFIG_MMC_OMAP_MODULE) || \
+#if defined(CONFIG_MMC_OMAP) || defined(CONFIG_MMC_OMAP_MODULE) || \
 	defined(CONFIG_MMC_OMAP_HS) || defined(CONFIG_MMC_OMAP_HS_MODULE)
 
 static inline void omap2_mmc_mux(struct omap_mmc_platform_data *mmc_controller,
diff --git a/arch/arm/mach-omap2/hsmmc.c b/arch/arm/mach-omap2/hsmmc.c
index 23cbdf6..f1d050a 100644
--- a/arch/arm/mach-omap2/hsmmc.c
+++ b/arch/arm/mach-omap2/hsmmc.c
@@ -1,5 +1,5 @@
 /*
- * linux/arch/arm/mach-omap2/board-sdp-hsmmc.c
+ * linux/arch/arm/mach-omap2/hsmmc.c
  *
  * Copyright (C) 2007-2008 Texas Instruments
  * Copyright (C) 2008 Nokia Corporation
@@ -101,6 +101,7 @@ static int hsmmc1_late_init(struct device *dev)
 
 err:
 	dev_err(dev, "Failed to configure TWL4030 GPIO IRQ\n");
+
 	return ret;
 }
 
@@ -232,7 +233,7 @@ static int hsmmc_twl_set_voltage(struct hsmmc_controller *c, int vdd)
 		return ret;
 
 	ret = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
-						vmmc, c->twl_mmc_dedicated);
+					vmmc, c->twl_mmc_dedicated);
 
 	return ret;
 }
@@ -331,8 +332,8 @@ static struct omap_mmc_platform_data mmc1_data = {
 						MMC_VDD_165_195,
 		.name			= "first slot",
 
-		.card_detect_irq        = TWL4030_GPIO_IRQ_NO(0),
-		.card_detect            = hsmmc1_card_detect,
+		.card_detect_irq	= TWL4030_GPIO_IRQ_NO(0),
+		.card_detect		= hsmmc1_card_detect,
 	},
 };
 
@@ -368,11 +369,4 @@ void __init hsmmc_init(int controller_mask)
 	omap2_init_mmc(hsmmc_data, OMAP34XX_NR_MMC);
 }
 
-#else
-
-void __init hsmmc_init(void)
-{
-
-}
-
 #endif
diff --git a/arch/arm/plat-omap/devices.c b/arch/arm/plat-omap/devices.c
index c22bd5f..25c6d10 100644
--- a/arch/arm/plat-omap/devices.c
+++ b/arch/arm/plat-omap/devices.c
@@ -191,7 +191,7 @@ void omap_mcbsp_register_board_cfg(struct omap_mcbsp_platform_data *config,
 
 /*-------------------------------------------------------------------------*/
 
-#if	defined(CONFIG_MMC_OMAP) || defined(CONFIG_MMC_OMAP_MODULE) || \
+#if defined(CONFIG_MMC_OMAP) || defined(CONFIG_MMC_OMAP_MODULE) || \
 	defined(CONFIG_MMC_OMAP_HS) || defined(CONFIG_MMC_OMAP_HS_MODULE)
 
 #define OMAP_MMC_NR_RES		2
diff --git a/arch/arm/plat-omap/include/mach/mmc.h b/arch/arm/plat-omap/include/mach/mmc.h
index 5e8ac72..0c2ef3b 100644
--- a/arch/arm/plat-omap/include/mach/mmc.h
+++ b/arch/arm/plat-omap/include/mach/mmc.h
@@ -111,6 +111,7 @@ void omap1_init_mmc(struct omap_mmc_platform_data **mmc_data,
 				int nr_controllers);
 void omap2_init_mmc(struct omap_mmc_platform_data **mmc_data,
 				int nr_controllers);
+void hsmmc_init(int controller_mask);
 int omap_mmc_add(int id, unsigned long base, unsigned long size,
 			unsigned int irq, struct omap_mmc_platform_data *data);
 #else
@@ -122,19 +123,14 @@ static inline void omap2_init_mmc(struct omap_mmc_platform_data **mmc_data,
 				int nr_controllers)
 {
 }
+static inline void hsmmc_init(int controller_mask)
+{
+}
 static inline int omap_mmc_add(int id, unsigned long base, unsigned long size,
 		unsigned int irq, struct omap_mmc_platform_data *data)
 {
 	return 0;
 }
-#endif
 
-#if defined(CONFIG_MMC_OMAP_HS) || defined(CONFIG_MMC_OMAP_HS_MODULE)
-void __init hsmmc_init(int controller_mask);
-#else
-static inline void hsmmc_init(void)
-{
-}
 #endif
-
 #endif
-- 
--- a/arch/arm/mach-omap2/board-overo.c
+++ b/arch/arm/mach-omap2/board-overo.c
@@ -214,7 +214,7 @@ static void __init overo_init(void)
 	omap_board_config = overo_config;
 	omap_board_config_size = ARRAY_SIZE(overo_config);
 	omap_serial_init();
-	hsmmc_init(HSMMC1);
+	hsmmc_init(HSMMC1 | HSMMC2);
 	usb_musb_init();
 	usb_ehci_init();
 	overo_flash_init();
--- a/arch/arm/mach-omap2/hsmmc.c
+++ b/arch/arm/mach-omap2/hsmmc.c
@@ -340,6 +340,7 @@ static struct omap_mmc_platform_data mmc
 static struct omap_mmc_platform_data mmc2_data = {
 	.nr_slots			= 1,
 	.slots[0] = {
+		.wire4			= 1,
 		.set_power		= hsmmc2_set_power,
 		.ocr_mask		= MMC_VDD_27_28 | MMC_VDD_28_29 |
 					  MMC_VDD_29_30 | MMC_VDD_30_31 |
--

